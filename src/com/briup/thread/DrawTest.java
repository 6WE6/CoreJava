package com.briup.thread;
/**
 * 之所以出现错误结果，是因为run方法的方法体不具有同步安全性，程序中有两个并发线程在修改Account对象，而且程序在线程睡眠代码处执行线程切换，切换给另一个修改Account对象的线程；
 * 解决方法：使用同步监视器(同步代码块)
 * 注：线程开始执行同步代码块之前，必须先获得对同步监视器的锁定；任何时刻只能有一个线程可以获得同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定
 * 同步监视器的目的：阻止两个线程对同一个共享资源进行并发访问，因此通常使用可能被并发访问的资源充当同步监视器
 * @author WE
 *
 */
public class DrawTest {

	public static void main(String[] args) {
		//创建一个账户
		AccountPlus acct = new AccountPlus("1234567",1000.0);
//		Account acct = new Account("1234567",1000.0);
		//模拟两个线程对同一个账户取钱
		new DrawThread("甲",acct,800).start(); 
		new DrawThread("乙",acct,800).start();

	}

	
	/**
	 * 释放同步监视器的锁定的总结
	 * 1.任何线程进入同步代码块，同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？程序无法显式释放对同步监视器的锁定，将在以下几种情况下释放对同步监视器的锁定：
	 * a:当前线程的同步方法，同步代码块执行结束
	 * b:当前线程在同步代码块和同步方法中遇到break,return终止了该代码块、该方法的继续执行
	 * c:当前线程在同步代码块，同步方法中出现了未处理的Error或Exception，导致该代码块，该方法异常结束
	 * d:当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait方法。
	 * 在如下情况下，线程不会释放同步监视器
	 * a:线程执行同步方法或同步代码块时，程序调用了Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器
	 * b:线程执行同步代码块时，其它线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器
	 * 
	 * 
	 * 
	 * 
	 */
	
}
